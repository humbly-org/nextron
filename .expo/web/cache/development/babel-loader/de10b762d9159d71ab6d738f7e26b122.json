{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { useReducer as $d70Aq$useReducer, useEffect as $d70Aq$useEffect, useState as $d70Aq$useState, useMemo as $d70Aq$useMemo } from \"react\";\n\nfunction $0d86e9c8f07f9a7b$export$762f73dccccd255d(options) {\n  var _options$initialItems = options.initialItems,\n      initialItems = _options$initialItems === void 0 ? [] : _options$initialItems,\n      initialSelectedKeys = options.initialSelectedKeys,\n      _options$getKey = options.getKey,\n      getKey = _options$getKey === void 0 ? function (item) {\n    return item.id || item.key;\n  } : _options$getKey,\n      filter = options.filter,\n      _options$initialFilte = options.initialFilterText,\n      initialFilterText = _options$initialFilte === void 0 ? '' : _options$initialFilte;\n\n  var _$d70Aq$useState = $d70Aq$useState({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  }),\n      _$d70Aq$useState2 = _slicedToArray(_$d70Aq$useState, 2),\n      state = _$d70Aq$useState2[0],\n      setState = _$d70Aq$useState2[1];\n\n  var filteredItems = $d70Aq$useMemo(function () {\n    return filter ? state.items.filter(function (item) {\n      return filter(item, state.filterText);\n    }) : state.items;\n  }, [state.items, state.filterText, filter]);\n  return _objectSpread(_objectSpread(_objectSpread({}, state), {}, {\n    items: filteredItems\n  }, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a({\n    getKey: getKey\n  }, setState)), {}, {\n    getItem: function getItem(key) {\n      return state.items.find(function (item) {\n        return getKey(item) === key;\n      });\n    }\n  });\n}\n\nfunction $0d86e9c8f07f9a7b$export$79c0c687a5963b0a(opts, dispatch) {\n  var cursor = opts.cursor,\n      getKey = opts.getKey;\n  return {\n    setSelectedKeys: function setSelectedKeys(selectedKeys) {\n      dispatch(function (state) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          selectedKeys: selectedKeys\n        });\n      });\n    },\n    setFilterText: function setFilterText(filterText) {\n      dispatch(function (state) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          filterText: filterText\n        });\n      });\n    },\n    insert: function insert(index) {\n      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        values[_key - 1] = arguments[_key];\n      }\n\n      dispatch(function (state) {\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, index].concat(values));\n      });\n    },\n    insertBefore: function insertBefore(key) {\n      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        values[_key2 - 1] = arguments[_key2];\n      }\n\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return;\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, index].concat(values));\n      });\n    },\n    insertAfter: function insertAfter(key) {\n      for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        values[_key3 - 1] = arguments[_key3];\n      }\n\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return;\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, index + 1].concat(values));\n      });\n    },\n    prepend: function prepend() {\n      for (var _len4 = arguments.length, values = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        values[_key4] = arguments[_key4];\n      }\n\n      dispatch(function (state) {\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, 0].concat(values));\n      });\n    },\n    append: function append() {\n      for (var _len5 = arguments.length, values = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        values[_key5] = arguments[_key5];\n      }\n\n      dispatch(function (state) {\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, state.items.length].concat(values));\n      });\n    },\n    remove: function remove() {\n      for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        keys[_key6] = arguments[_key6];\n      }\n\n      dispatch(function (state) {\n        var keySet = new Set(keys);\n        var items = state.items.filter(function (item) {\n          return !keySet.has(getKey(item));\n        });\n        var selection = 'all';\n\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n\n          for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {\n            var key = _step.value;\n            selection.delete(key);\n          }\n        }\n\n        if (cursor == null && items.length === 0) selection = new Set();\n        return _objectSpread(_objectSpread({}, state), {}, {\n          items: items,\n          selectedKeys: selection\n        });\n      });\n    },\n    removeSelectedItems: function removeSelectedItems() {\n      dispatch(function (state) {\n        if (state.selectedKeys === 'all') return _objectSpread(_objectSpread({}, state), {}, {\n          items: [],\n          selectedKeys: new Set()\n        });\n        var selectedKeys = state.selectedKeys;\n        var items = state.items.filter(function (item) {\n          return !selectedKeys.has(getKey(item));\n        });\n        return _objectSpread(_objectSpread({}, state), {}, {\n          items: items,\n          selectedKeys: new Set()\n        });\n      });\n    },\n    move: function move(key, toIndex) {\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return state;\n        var copy = state.items.slice();\n\n        var _copy$splice = copy.splice(index, 1),\n            _copy$splice2 = _slicedToArray(_copy$splice, 1),\n            item1 = _copy$splice2[0];\n\n        copy.splice(toIndex, 0, item1);\n        return _objectSpread(_objectSpread({}, state), {}, {\n          items: copy\n        });\n      });\n    },\n    moveBefore: function moveBefore(key1, keys) {\n      dispatch(function (state) {\n        var toIndex = state.items.findIndex(function (item) {\n          return getKey(item) === key1;\n        });\n        if (toIndex === -1) return state;\n        var indices = keys.map(function (key) {\n          return state.items.findIndex(function (item) {\n            return getKey(item) === key;\n          });\n        }).sort();\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex);\n      });\n    },\n    moveAfter: function moveAfter(key2, keys) {\n      dispatch(function (state) {\n        var toIndex = state.items.findIndex(function (item) {\n          return getKey(item) === key2;\n        });\n        if (toIndex === -1) return state;\n        var indices = keys.map(function (key) {\n          return state.items.findIndex(function (item) {\n            return getKey(item) === key;\n          });\n        }).sort();\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex + 1);\n      });\n    },\n    update: function update(key, newValue) {\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return state;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          items: [].concat(_toConsumableArray(state.items.slice(0, index)), [newValue], _toConsumableArray(state.items.slice(index + 1)))\n        });\n      });\n    }\n  };\n}\n\nfunction $0d86e9c8f07f9a7b$var$insert(state, index) {\n  for (var _len7 = arguments.length, values = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {\n    values[_key7 - 2] = arguments[_key7];\n  }\n\n  return _objectSpread(_objectSpread({}, state), {}, {\n    items: [].concat(_toConsumableArray(state.items.slice(0, index)), values, _toConsumableArray(state.items.slice(index)))\n  });\n}\n\nfunction $0d86e9c8f07f9a7b$var$move(state, indices, toIndex) {\n  for (var _iterator2 = _createForOfIteratorHelperLoose(indices), _step2; !(_step2 = _iterator2()).done;) {\n    var index = _step2.value;\n    if (index < toIndex) toIndex--;\n  }\n\n  var moves = indices.map(function (from) {\n    return {\n      from: from,\n      to: toIndex++\n    };\n  });\n\n  for (var i = 0; i < moves.length; i++) {\n    var a = moves[i].from;\n\n    for (var j = i; j < moves.length; j++) {\n      var b = moves[j].from;\n      if (b > a) moves[j].from--;\n    }\n  }\n\n  for (var i1 = 0; i1 < moves.length; i1++) {\n    var _a = moves[i1];\n\n    for (var _j = moves.length - 1; _j > i1; _j--) {\n      var _b = moves[_j];\n      if (_b.from < _a.to) _a.to++;else _b.from++;\n    }\n  }\n\n  var copy = state.items.slice();\n\n  for (var _iterator3 = _createForOfIteratorHelperLoose(moves), _step3; !(_step3 = _iterator3()).done;) {\n    var move = _step3.value;\n\n    var _copy$splice3 = copy.splice(move.from, 1),\n        _copy$splice4 = _slicedToArray(_copy$splice3, 1),\n        item = _copy$splice4[0];\n\n    copy.splice(move.to, 0, item);\n  }\n\n  return _objectSpread(_objectSpread({}, state), {}, {\n    items: copy\n  });\n}\n\nfunction $f86e6c1ec7da6ebb$var$reducer(data, action) {\n  var selectedKeys;\n\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          var _filterText, _sortDescriptor;\n\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_filterText = action.filterText) !== null && _filterText !== void 0 ? _filterText : data.filterText,\n            state: action.type,\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: (_sortDescriptor = action.sortDescriptor) !== null && _sortDescriptor !== void 0 ? _sortDescriptor : data.sortDescriptor,\n            abortController: action.abortController\n          });\n\n        case 'update':\n          return _objectSpread(_objectSpread({}, data), action.updater(data));\n\n        case 'success':\n        case 'error':\n          return data;\n\n        default:\n          throw new Error(\"Invalid action \\\"\" + action.type + \"\\\" in state \\\"\" + data.state + \"\\\"\");\n      }\n\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          if (action.abortController !== data.abortController) return data;\n\n          var _selectedKeys;\n\n          selectedKeys = (_selectedKeys = action.selectedKeys) !== null && _selectedKeys !== void 0 ? _selectedKeys : data.selectedKeys;\n\n          var _filterText1, _sortDescriptor1;\n\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_filterText1 = action.filterText) !== null && _filterText1 !== void 0 ? _filterText1 : data.filterText,\n            state: 'idle',\n            items: _toConsumableArray(action.items),\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: (_sortDescriptor1 = action.sortDescriptor) !== null && _sortDescriptor1 !== void 0 ? _sortDescriptor1 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          });\n\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            state: 'error',\n            error: action.error,\n            abortController: null\n          });\n\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          data.abortController.abort();\n\n          var _filterText2;\n\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_filterText2 = action.filterText) !== null && _filterText2 !== void 0 ? _filterText2 : data.filterText,\n            state: action.type,\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          });\n\n        case 'update':\n          return _objectSpread(_objectSpread({}, data), action.updater(data));\n\n        default:\n          throw new Error(\"Invalid action \\\"\" + action.type + \"\\\" in state \\\"\" + data.state + \"\\\"\");\n      }\n\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          var _selectedKeys1;\n\n          selectedKeys = data.selectedKeys === 'all' || action.selectedKeys === 'all' ? 'all' : new Set([].concat(_toConsumableArray(data.selectedKeys), _toConsumableArray((_selectedKeys1 = action.selectedKeys) !== null && _selectedKeys1 !== void 0 ? _selectedKeys1 : [])));\n\n          var _sortDescriptor2;\n\n          return _objectSpread(_objectSpread({}, data), {}, {\n            state: 'idle',\n            items: [].concat(_toConsumableArray(data.items), _toConsumableArray(action.items)),\n            selectedKeys: selectedKeys,\n            sortDescriptor: (_sortDescriptor2 = action.sortDescriptor) !== null && _sortDescriptor2 !== void 0 ? _sortDescriptor2 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          });\n\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            state: 'error',\n            error: action.error\n          });\n\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          data.abortController.abort();\n\n          var _filterText3;\n\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_filterText3 = action.filterText) !== null && _filterText3 !== void 0 ? _filterText3 : data.filterText,\n            state: action.type,\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          });\n\n        case 'loadingMore':\n          action.abortController.abort();\n          return data;\n\n        case 'update':\n          return _objectSpread(_objectSpread({}, data), action.updater(data));\n\n        default:\n          throw new Error(\"Invalid action \\\"\" + action.type + \"\\\" in state \\\"\" + data.state + \"\\\"\");\n      }\n\n    default:\n      throw new Error(\"Invalid state \\\"\" + data.state + \"\\\"\");\n  }\n}\n\nfunction $f86e6c1ec7da6ebb$export$bc3384a35de93d66(options) {\n  var load = options.load,\n      _sort = options.sort,\n      initialSelectedKeys = options.initialSelectedKeys,\n      initialSortDescriptor = options.initialSortDescriptor,\n      _options$getKey2 = options.getKey,\n      getKey = _options$getKey2 === void 0 ? function (item) {\n    return item.id || item.key;\n  } : _options$getKey2,\n      _options$initialFilte2 = options.initialFilterText,\n      initialFilterText = _options$initialFilte2 === void 0 ? '' : _options$initialFilte2;\n\n  var _$d70Aq$useReducer = $d70Aq$useReducer($f86e6c1ec7da6ebb$var$reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  }),\n      _$d70Aq$useReducer2 = _slicedToArray(_$d70Aq$useReducer, 2),\n      data = _$d70Aq$useReducer2[0],\n      dispatch = _$d70Aq$useReducer2[1];\n\n  var dispatchFetch = function dispatchFetch(action, fn) {\n    var abortController, _filterText, previousFilterText, _sortDescriptor, response, _filterText4, filterText;\n\n    return _regeneratorRuntime.async(function dispatchFetch$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            abortController = new AbortController();\n            _context.prev = 1;\n            dispatch(_objectSpread(_objectSpread({}, action), {}, {\n              abortController: abortController\n            }));\n            previousFilterText = (_filterText = action.filterText) !== null && _filterText !== void 0 ? _filterText : data.filterText;\n            _context.next = 6;\n            return _regeneratorRuntime.awrap(fn({\n              items: data.items.slice(),\n              selectedKeys: data.selectedKeys,\n              sortDescriptor: (_sortDescriptor = action.sortDescriptor) !== null && _sortDescriptor !== void 0 ? _sortDescriptor : data.sortDescriptor,\n              signal: abortController.signal,\n              cursor: action.type === 'loadingMore' ? data.cursor : null,\n              filterText: previousFilterText\n            }));\n\n          case 6:\n            response = _context.sent;\n            filterText = (_filterText4 = response.filterText) !== null && _filterText4 !== void 0 ? _filterText4 : previousFilterText;\n            dispatch(_objectSpread(_objectSpread({\n              type: 'success'\n            }, response), {}, {\n              abortController: abortController\n            }));\n            if (filterText && filterText !== previousFilterText && !abortController.signal.aborted) dispatchFetch({\n              type: 'filtering',\n              filterText: filterText\n            }, load);\n            _context.next = 15;\n            break;\n\n          case 12:\n            _context.prev = 12;\n            _context.t0 = _context[\"catch\"](1);\n            dispatch({\n              type: 'error',\n              error: _context.t0,\n              abortController: abortController\n            });\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[1, 12]], Promise);\n  };\n\n  $d70Aq$useEffect(function () {\n    dispatchFetch({\n      type: 'loading'\n    }, load);\n  }, []);\n  return _objectSpread(_objectSpread({\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem: function getItem(key) {\n      return data.items.find(function (item) {\n        return getKey(item) === key;\n      });\n    },\n    reload: function reload() {\n      dispatchFetch({\n        type: 'loading'\n      }, load);\n    },\n    loadMore: function loadMore() {\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) return;\n      dispatchFetch({\n        type: 'loadingMore'\n      }, load);\n    },\n    sort: function sort(sortDescriptor) {\n      dispatchFetch({\n        type: 'sorting',\n        sortDescriptor: sortDescriptor\n      }, _sort || load);\n    }\n  }, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a(_objectSpread(_objectSpread({}, options), {}, {\n    getKey: getKey,\n    cursor: data.cursor\n  }), function (fn) {\n    dispatch({\n      type: 'update',\n      updater: fn\n    });\n  })), {}, {\n    setFilterText: function setFilterText(filterText) {\n      dispatchFetch({\n        type: 'filtering',\n        filterText: filterText\n      }, load);\n    }\n  });\n}\n\nfunction $be2ea0343af54212$export$d14e1352e21f4a16(options) {\n  var _options$initialItems2 = options.initialItems,\n      initialItems1 = _options$initialItems2 === void 0 ? [] : _options$initialItems2,\n      initialSelectedKeys = options.initialSelectedKeys,\n      _options$getKey3 = options.getKey,\n      getKey = _options$getKey3 === void 0 ? function (item) {\n    return item.id || item.key;\n  } : _options$getKey3,\n      _options$getChildren = options.getChildren,\n      getChildren = _options$getChildren === void 0 ? function (item) {\n    return item.children;\n  } : _options$getChildren;\n  var map = $d70Aq$useMemo(function () {\n    return new Map();\n  }, []);\n  var initialNodes = $d70Aq$useMemo(function () {\n    return buildTree(initialItems1);\n  }, []);\n\n  var _$d70Aq$useState3 = $d70Aq$useState(initialNodes),\n      _$d70Aq$useState4 = _slicedToArray(_$d70Aq$useState3, 2),\n      items1 = _$d70Aq$useState4[0],\n      setItems = _$d70Aq$useState4[1];\n\n  var _$d70Aq$useState5 = $d70Aq$useState(new Set(initialSelectedKeys || [])),\n      _$d70Aq$useState6 = _slicedToArray(_$d70Aq$useState5, 2),\n      selectedKeys = _$d70Aq$useState6[0],\n      setSelectedKeys = _$d70Aq$useState6[1];\n\n  function buildTree() {\n    var initialItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var parentKey = arguments.length > 1 ? arguments[1] : undefined;\n    return initialItems.map(function (item) {\n      var node = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n\n  function updateTree(items, key, update) {\n    var node = map.get(key);\n    if (!node) return items;\n    var newNode = update(node);\n    if (newNode == null) deleteNode(node);else addNode(newNode);\n\n    while (node.parentKey) {\n      var nextParent = map.get(node.parentKey);\n      var copy = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n      var children = nextParent.children;\n      if (newNode == null) children = children.filter(function (c) {\n        return c !== node;\n      });\n      copy.children = children.map(function (child) {\n        if (child === node) return newNode;\n        return child;\n      });\n      map.set(copy.key, copy);\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) items = items.filter(function (c) {\n      return c !== node;\n    });\n    return items.map(function (item) {\n      if (item === node) return newNode;\n      return item;\n    });\n  }\n\n  function addNode(node) {\n    map.set(node.key, node);\n\n    for (var _iterator4 = _createForOfIteratorHelperLoose(node.children), _step4; !(_step4 = _iterator4()).done;) {\n      var child = _step4.value;\n      addNode(child);\n    }\n  }\n\n  function deleteNode(node) {\n    map.delete(node.key);\n\n    for (var _iterator5 = _createForOfIteratorHelperLoose(node.children), _step5; !(_step5 = _iterator5()).done;) {\n      var child = _step5.value;\n      deleteNode(child);\n    }\n  }\n\n  return {\n    items: items1,\n    selectedKeys: selectedKeys,\n    setSelectedKeys: setSelectedKeys,\n    getItem: function getItem(key) {\n      return map.get(key);\n    },\n    insert: function insert(parentKey, index) {\n      for (var _len8 = arguments.length, values = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {\n        values[_key8 - 2] = arguments[_key8];\n      }\n\n      setItems(function (items) {\n        var nodes = buildTree(values, parentKey);\n        if (parentKey == null) return [].concat(_toConsumableArray(items.slice(0, index)), _toConsumableArray(nodes), _toConsumableArray(items.slice(index)));\n        return updateTree(items, parentKey, function (parentNode) {\n          return {\n            key: parentNode.key,\n            parentKey: parentNode.parentKey,\n            value: parentNode.value,\n            children: [].concat(_toConsumableArray(parentNode.children.slice(0, index)), _toConsumableArray(nodes), _toConsumableArray(parentNode.children.slice(index)))\n          };\n        });\n      });\n    },\n    insertBefore: function insertBefore(key) {\n      var node = map.get(key);\n      if (!node) return;\n      var parentNode = map.get(node.parentKey);\n      var nodes = parentNode ? parentNode.children : items1;\n      var index = nodes.indexOf(node);\n\n      for (var _len9 = arguments.length, values = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n        values[_key9 - 1] = arguments[_key9];\n      }\n\n      this.insert.apply(this, [parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index].concat(values));\n    },\n    insertAfter: function insertAfter(key) {\n      var node = map.get(key);\n      if (!node) return;\n      var parentNode = map.get(node.parentKey);\n      var nodes = parentNode ? parentNode.children : items1;\n      var index = nodes.indexOf(node);\n\n      for (var _len10 = arguments.length, values = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n        values[_key10 - 1] = arguments[_key10];\n      }\n\n      this.insert.apply(this, [parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index + 1].concat(values));\n    },\n    prepend: function prepend(parentKey) {\n      for (var _len11 = arguments.length, values = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n        values[_key11 - 1] = arguments[_key11];\n      }\n\n      this.insert.apply(this, [parentKey, 0].concat(values));\n    },\n    append: function append(parentKey) {\n      for (var _len12 = arguments.length, values = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n        values[_key12 - 1] = arguments[_key12];\n      }\n\n      if (parentKey == null) this.insert.apply(this, [null, items1.length].concat(values));else {\n        var parentNode = map.get(parentKey);\n        if (!parentNode) return;\n        this.insert.apply(this, [parentKey, parentNode.children.length].concat(values));\n      }\n    },\n    remove: function remove() {\n      var newItems = items1;\n\n      for (var _len13 = arguments.length, keys = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        keys[_key13] = arguments[_key13];\n      }\n\n      for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n        var key = _keys[_i];\n        newItems = updateTree(newItems, key, function () {\n          return null;\n        });\n      }\n\n      setItems(newItems);\n      var selection = new Set(selectedKeys);\n\n      for (var _iterator6 = _createForOfIteratorHelperLoose(selectedKeys), _step6; !(_step6 = _iterator6()).done;) {\n        var key1 = _step6.value;\n        if (!map.has(key1)) selection.delete(key1);\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems: function removeSelectedItems() {\n      this.remove.apply(this, _toConsumableArray(selectedKeys));\n    },\n    move: function move(key, toParentKey, index) {\n      setItems(function (items) {\n        var node = map.get(key);\n        if (!node) return items;\n        items = updateTree(items, key, function () {\n          return null;\n        });\n\n        var movedNode = _objectSpread(_objectSpread({}, node), {}, {\n          parentKey: toParentKey\n        });\n\n        return updateTree(items, toParentKey, function (parentNode) {\n          return {\n            key: parentNode.key,\n            parentKey: parentNode.parentKey,\n            value: parentNode.value,\n            children: [].concat(_toConsumableArray(parentNode.children.slice(0, index)), [movedNode], _toConsumableArray(parentNode.children.slice(index)))\n          };\n        });\n      });\n    },\n    update: function update(oldKey, newValue) {\n      setItems(function (items) {\n        return updateTree(items, oldKey, function (oldNode) {\n          var node = {\n            key: oldNode.key,\n            parentKey: oldNode.parentKey,\n            value: newValue,\n            children: null\n          };\n          node.children = buildTree(getChildren(newValue), node.key);\n          return node;\n        });\n      });\n    }\n  };\n}\n\nexport { $f86e6c1ec7da6ebb$export$bc3384a35de93d66 as useAsyncList, $be2ea0343af54212$export$d14e1352e21f4a16 as useTreeData, $0d86e9c8f07f9a7b$export$762f73dccccd255d as useListData };","map":{"version":3,"sources":["packages/@react-stately/data/src/useAsyncList.ts","packages/@react-stately/data/src/useListData.ts","packages/@react-stately/data/src/useTreeData.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createListActions, ListData, ListState} from './useListData';\nimport {Key, Reducer, useEffect, useReducer} from 'react';\nimport {LoadingState, Selection, SortDescriptor} from '@react-types/shared';\n\nexport interface AsyncListOptions<T, C> {\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** The initial sort descriptor. */\n  initialSortDescriptor?: SortDescriptor,\n  /** The initial filter text. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that loads the data for the items in the list. */\n  load: AsyncListLoadFunction<T, C>,\n  /**\n   * An optional function that performs sorting. If not provided,\n   * then `sortDescriptor` is passed to the `load` function.\n   */\n  sort?: AsyncListLoadFunction<T, C>\n}\n\ntype AsyncListLoadFunction<T, C> = (state: AsyncListLoadOptions<T, C>) => AsyncListStateUpdate<T, C> | Promise<AsyncListStateUpdate<T, C>>;\n\ninterface AsyncListLoadOptions<T, C> {\n  /** The items currently in the list. */\n  items: T[],\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n  /** The current sort descriptor for the list. */\n  sortDescriptor: SortDescriptor,\n  /** An abort signal used to notify the load function that the request has been aborted. */\n  signal: AbortSignal,\n  /** The pagination cursor returned from the last page load. */\n  cursor?: C,\n  /** The current filter text used to perform server side filtering. */\n  filterText?: string,\n  /** The current loading state of the list. */\n  loadingState?: LoadingState\n}\n\ninterface AsyncListStateUpdate<T, C> {\n  /** The new items to append to the list. */\n  items: Iterable<T>,\n  /** The keys to add to the selection. */\n  selectedKeys?: Iterable<Key>,\n  /** The sort descriptor to set. */\n  sortDescriptor?: SortDescriptor,\n  /** The pagination cursor to be used for the next page load. */\n  cursor?: C,\n  /** The updated filter text for the list. */\n  filterText?: string\n}\n\ninterface AsyncListState<T, C> extends ListState<T> {\n  state: LoadingState,\n  items: T[],\n  // disabledKeys?: Iterable<Key>,\n  selectedKeys: Selection,\n  // selectedKey?: Key,\n  // expandedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  cursor?: C\n}\n\ntype ActionType = 'success' | 'error' | 'loading' | 'loadingMore' | 'sorting' | 'update' | 'filtering';\ninterface Action<T, C> {\n  type: ActionType,\n  items?: Iterable<T>,\n  selectedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  updater?: (state: ListState<T>) => ListState<T>,\n  cursor?: C,\n  filterText?: string\n}\n\nexport interface AsyncListData<T> extends ListData<T> {\n  /** Whether data is currently being loaded. */\n  isLoading: boolean,\n  /** If loading data failed, then this contains the error that occurred. */\n  error?: Error,\n  // disabledKeys?: Set<Key>,\n  // selectedKey?: Key,\n  // expandedKeys?: Set<Key>,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n\n  /** Reloads the data in the list. */\n  reload(): void,\n  /** Loads the next page of data in the list. */\n  loadMore(): void,\n  /** Triggers sorting for the list. */\n  sort(descriptor: SortDescriptor): void,\n  /** The current loading state for the list. */\n  loadingState: LoadingState\n}\n\nfunction reducer<T, C>(data: AsyncListState<T, C>, action: Action<T, C>): AsyncListState<T, C> {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          selectedKeys = action.selectedKeys ?? data.selectedKeys;\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          selectedKeys = (data.selectedKeys === 'all' || action.selectedKeys === 'all')\n            ? 'all'\n            : new Set([...data.selectedKeys, ...(action.selectedKeys ?? [])]);\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\nexport function useAsyncList<T, C = string>(options: AsyncListOptions<T, C>): AsyncListData<T> {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = (item: any) => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n\n  let [data, dispatch] = useReducer<Reducer<AsyncListState<T, C>, Action<T, C>>>(reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n\n  const dispatchFetch = async (action: Action<T, C>, fn: AsyncListLoadFunction<T, C>) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({...action, abortController});\n      let previousFilterText = action.filterText ?? data.filterText;\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n\n      let filterText = response.filterText ?? previousFilterText;\n      dispatch({type: 'success', ...response, abortController});\n\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && (filterText !== previousFilterText) && !abortController.signal.aborted) {\n        dispatchFetch({type: 'filtering', filterText}, load);\n      }\n    } catch (e) {\n      dispatch({type: 'error', error: e, abortController});\n    }\n  };\n\n  useEffect(() => {\n    dispatchFetch({type: 'loading'}, load);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key: Key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({type: 'loading'}, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({type: 'loadingMore'}, load);\n    },\n    sort(sortDescriptor: SortDescriptor) {\n      dispatchFetch({type: 'sorting', sortDescriptor}, sort || load);\n    },\n    ...createListActions({...options, getKey, cursor: data.cursor}, fn => {\n      dispatch({type: 'update', updater: fn});\n    }),\n    setFilterText(filterText: string) {\n      dispatchFetch({type: 'filtering', filterText}, load);\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\nimport {Selection} from '@react-types/shared';\n\nexport interface ListOptions<T> {\n  /** Initial items in the list. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: 'all' | Iterable<Key>,\n  /** The initial text to filter the list by. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns whether a item matches the current filter text. */\n  filter?: (item: T, filterText: string) => boolean\n}\n\nexport interface ListData<T> {\n  /** The items in the list. */\n  items: T[],\n\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Selection): void,\n\n  /** The current filter text. */\n  filterText: string,\n\n  /** Sets the filter text. */\n  setFilterText(filterText: string): void,\n\n  /**\n   * Gets an item from the list by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): T,\n\n  /**\n   * Inserts items into the list at the given index.\n   * @param index - The index to insert into.\n   * @param values - The values to insert.\n   */\n  insert(index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends items to the list.\n   * @param values - The values to insert.\n   */\n  append(...values: T[]): void,\n\n  /**\n   * Prepends items to the list.\n   * @param value - The value to insert.\n   */\n  prepend(...values: T[]): void,\n\n  /**\n   * Removes items from the list by their keys.\n   * @param keys - The keys of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the list that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the list.\n   * @param key - The key of the item to move.\n   * @param toIndex - The index to move the item to.\n   */\n  move(key: Key, toIndex: number): void,\n\n  /**\n   * Moves one or more items before a given key.\n   * @param key - The key of the item to move the items before.\n   * @param keys - The keys of the items to move.\n   */\n  moveBefore(key: Key, keys: Key[]): void,\n\n  /**\n   * Moves one or more items after a given key.\n   * @param key - The key of the item to move the items after.\n   * @param keys - The keys of the items to move.\n   */\n  moveAfter(key: Key, keys: Key[]): void,\n\n  /**\n   * Updates an item in the list.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\nexport interface ListState<T> {\n  items: T[],\n  selectedKeys: Selection,\n  filterText: string\n}\n\ninterface CreateListOptions<T, C> extends ListOptions<T> {\n  cursor?: C\n}\n\n/**\n * Manages state for an immutable list data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useListData<T>(options: ListOptions<T>): ListData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    filter,\n    initialFilterText = ''\n  } = options;\n\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  let [state, setState] = useState<ListState<T>>({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n\n  let filteredItems = useMemo(\n    () => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items,\n    [state.items, state.filterText, filter]);\n\n  return {\n    ...state,\n    items: filteredItems,\n    ...createListActions({getKey}, setState),\n    getItem(key: Key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\n\nexport function createListActions<T, C>(opts: CreateListOptions<T, C>, dispatch: (updater: (state: ListState<T>) => ListState<T>) => void): Omit<ListData<T>, 'items' | 'selectedKeys' | 'getItem' | 'filterText'> {\n  let {cursor, getKey} = opts;\n  return {\n    setSelectedKeys(selectedKeys: Selection) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys\n      }));\n    },\n    setFilterText(filterText: string) {\n      dispatch(state => ({\n        ...state,\n        filterText\n      }));\n    },\n    insert(index: number, ...values: T[]) {\n      dispatch(state => insert(state, index, ...values));\n    },\n    insertBefore(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index, ...values);\n      });\n    },\n    insertAfter(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values: T[]) {\n      dispatch(state => insert(state, 0, ...values));\n    },\n    append(...values: T[]) {\n      dispatch(state => insert(state, state.items.length, ...values));\n    },\n    remove(...keys: Key[]) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n\n        let selection: Selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (let key of keys) {\n            selection.delete(key);\n          }\n        }\n        if (cursor == null && items.length === 0) {\n          selection = new Set();\n        }\n\n        return {\n          ...state,\n          items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') {\n          return {\n            ...state,\n            items: [],\n            selectedKeys: new Set()\n          };\n        }\n\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key: Key, toIndex: number) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    moveBefore(key: Key, keys: Key[]) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        let indices = keys.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return move(state, indices, toIndex);\n      });\n    },\n    moveAfter(key: Key, keys: Key[]) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        let indices = keys.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return move(state, indices, toIndex + 1);\n      });\n    },\n    update(key: Key, newValue: T) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        return {\n          ...state,\n          items: [\n            ...state.items.slice(0, index),\n            newValue,\n            ...state.items.slice(index + 1)\n          ]\n        };\n      });\n    }\n  };\n}\n\nfunction insert<T>(state: ListState<T>, index: number, ...values: T[]): ListState<T> {\n  return {\n    ...state,\n    items: [\n      ...state.items.slice(0, index),\n      ...values,\n      ...state.items.slice(index)\n    ]\n  };\n}\n\nfunction move<T>(state: ListState<T>, indices: number[], toIndex: number): ListState<T> {\n  // Shift the target down by the number of items being moved from before the target\n  for (let index of indices) {\n    if (index < toIndex) {\n      toIndex--;\n    }\n  }\n\n  let moves = indices.map(from => ({\n    from,\n    to: toIndex++\n  }));\n\n  // Shift later from indices down if they have a larger index\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n\n      if (b > a) {\n        moves[j].from--;\n      }\n    }\n  }\n\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i];\n    for (let j = moves.length - 1; j > i; j--) {\n      let b = moves[j];\n\n      if (b.from < a.to) {\n        a.to++;\n      } else {\n        b.from++;\n      }\n    }\n  }\n\n  let copy = state.items.slice();\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n\n  return {\n    ...state,\n    items: copy\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\n\nexport interface TreeOptions<T extends object> {\n  /** Initial root items in the tree. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns the children for an item object. */\n  getChildren?: (item: T) => T[]\n}\n\ninterface TreeNode<T extends object> {\n  /** A unique key for the tree node. */\n  key: Key,\n  /** The key of the parent node. */\n  parentKey: Key,\n  /** The value object for the tree node. */\n  value: T,\n  /** Children of the tree node. */\n  children: TreeNode<T>[]\n}\n\nexport interface TreeData<T extends object> {\n  /** The root nodes in the tree. */\n  items: TreeNode<T>[],\n\n  /** The keys of the currently selected items in the tree. */\n  selectedKeys: Set<Key>,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Set<Key>): void,\n\n  /**\n   * Gets a node from the tree by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): TreeNode<T>,\n\n  /**\n   * Inserts an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param index - The index within the parent to insert into.\n   * @param value - The value to insert.\n   */\n  insert(parentKey: Key | null, index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  append(parentKey: Key | null, ...values: T[]): void,\n\n  /**\n   * Prepends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  prepend(parentKey: Key | null, ...value: T[]): void,\n\n  /**\n   * Removes an item from the tree by its key.\n   * @param key - The key of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the tree that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the tree.\n   * @param key - The key of the item to move.\n   * @param toParentKey - The key of the new parent to insert into.\n   * @param index - The index within the new parent to insert at.\n   */\n  move(key: Key, toParentKey: Key, index: number): void,\n\n  /**\n   * Updates an item in the tree.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useTreeData<T extends object>(options: TreeOptions<T>): TreeData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    getChildren = (item: any) => item.children\n  } = options;\n  let map = useMemo(() => new Map<Key, TreeNode<T>>(), []);\n\n  // We only want to compute this on initial render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  let initialNodes = useMemo(() => buildTree(initialItems), []);\n  let [items, setItems] = useState(initialNodes);\n  let [selectedKeys, setSelectedKeys] = useState(new Set<Key>(initialSelectedKeys || []));\n\n  function buildTree(initialItems: T[] = [], parentKey?: Key | null) {\n    return initialItems.map(item => {\n      let node: TreeNode<T> = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n\n  function updateTree(items: TreeNode<T>[], key: Key, update: (node: TreeNode<T>) => TreeNode<T>) {\n    let node = map.get(key);\n    if (!node) {\n      return items;\n    }\n\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) {\n      deleteNode(node);\n    } else {\n      addNode(newNode);\n    }\n\n    // Walk up the tree and update each parent to refer to the new chilren.\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy: TreeNode<T> = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n\n      let children = nextParent.children;\n      if (newNode == null) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children.map(child => {\n        if (child === node) {\n          return newNode;\n        }\n\n        return child;\n      });\n\n      map.set(copy.key, copy);\n\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return items.map(item => {\n      if (item === node) {\n        return newNode;\n      }\n\n      return item;\n    });\n  }\n\n  function addNode(node: TreeNode<T>) {\n    map.set(node.key, node);\n    for (let child of node.children) {\n      addNode(child);\n    }\n  }\n\n  function deleteNode(node: TreeNode<T>) {\n    map.delete(node.key);\n    for (let child of node.children) {\n      deleteNode(child);\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n    getItem(key: Key) {\n      return map.get(key);\n    },\n    insert(parentKey: Key | null, index: number, ...values: T[]) {\n      setItems(items => {\n        let nodes = buildTree(values, parentKey);\n\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) {\n          return [\n            ...items.slice(0, index),\n            ...nodes,\n            ...items.slice(index)\n          ];\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            ...nodes,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    insertBefore(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index, ...values);\n    },\n    insertAfter(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index + 1, ...values);\n    },\n    prepend(parentKey: Key | null, ...values: T[]) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey: Key | null, ...values: T[]) {\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = map.get(parentKey);\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys: Key[]) {\n      let newItems = items;\n      for (let key of keys) {\n        newItems = updateTree(newItems, key, () => null);\n      }\n\n      setItems(newItems);\n\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) {\n        if (!map.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key: Key, toParentKey: Key, index: number) {\n      setItems(items => {\n        let node = map.get(key);\n        if (!node) {\n          return items;\n        }\n\n        items = updateTree(items, key, () => null);\n\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n\n        return updateTree(items, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            movedNode,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    update(oldKey: Key, newValue: T) {\n      setItems(items => updateTree(items, oldKey, oldNode => {\n        let node: TreeNode<T> = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n\n        node.children = buildTree(getChildren(newValue), node.key);\n        return node;\n      }));\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}